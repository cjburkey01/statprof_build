<script type="text/hyperscript">
    behavior ZScoreTextUpdate
        on keyup or input
            set mean to the value of #z_score_calc_mean
            set stdev to the value of #z_score_calc_stdev
            set x to the value of #z_score_calc_x

            if has_val(mean) and has_val(stdev) and has_val(x)
                set z_score to z_score_fn(mean, stdev, x)
                set the value of #z_score_output to z_score.toFixed(6)
            end
        end
    end

    behavior NormCalcTextUpdate
        on keyup or input
            set mean to the value of #norm_prob_calc_mean
            set stdev to the value of #norm_prob_calc_stdev
            set lt to the value of #norm_prob_calc_lt
            set gt to the value of #norm_prob_calc_gt

            if has_val(mean) and has_val(stdev)
                set the value of #norm_prob_output 
                        to norm_prob_cdf_gt_lt(mean, stdev, lt, gt).toFixed(6)
            end
        end
    end

    behavior SampleNormCalcTextUpdate
        on keyup or input
            set mean to the value of #sample_norm_prob_calc_mean
            set stdev to the value of #sample_norm_prob_calc_stdev
            set n to the value of #sample_norm_prob_calc_n
            set lt to the value of #sample_norm_prob_calc_lt
            set gt to the value of #sample_norm_prob_calc_gt

            if has_val(mean) and has_val(stdev) and has_val(n)
                set n to Math.max(Math.floor(n), 1)
                set stdev to stdev / Math.sqrt(n)

                set the value of #sample_norm_prob_calc_output 
                        to norm_prob_cdf_gt_lt(mean, stdev, lt, gt)
            end
        end
    end

    behavior InvNormCalcTextUpdate
        on keyup or input
            set mean to the value of #inv_norm_prob_calc_mean
            set stdev to the value of #inv_norm_prob_calc_stdev
            set p to the value of #inv_norm_prob_calc_p

            if has_val(mean) and has_val(stdev) and has_val(p)
                set p to Math.min(Math.max(p, 0.0), 1.0)

                set lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, p)) as Float
                set gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - p)) as Float

                set the value of #inv_norm_prob_lt to lt.toFixed(6)
                set the value of #inv_norm_prob_gt to gt.toFixed(6)

                set half_p to (1.0 - p) / 2.0

                set btwn_gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, half_p)) as Float
                set btwn_lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - half_p)) as Float

                set the value of #inv_norm_prob_btwn1 to btwn_gt.toFixed(6)
                set the value of #inv_norm_prob_btwn2 to btwn_lt.toFixed(6)

                set half_p2 to p / 2.0

                set out_lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, half_p2)) as Float
                set out_gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - half_p2)) as Float

                set the value of #inv_norm_prob_out1 to out_lt.toFixed(6)
                set the value of #inv_norm_prob_out2 to out_gt.toFixed(6)
            end
        end
    end

    behavior InvNormCalcTextUpdate
        on keyup or input
            set mean to the value of #inv_norm_prob_calc_mean
            set stdev to the value of #inv_norm_prob_calc_stdev
            set p to the value of #inv_norm_prob_calc_p

            if has_val(mean) and has_val(stdev) and has_val(p)
                set p to Math.min(Math.max(p, 0.0), 1.0)

                set lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, p)) as Float
                set gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - p)) as Float

                set the value of #inv_norm_prob_lt to lt.toFixed(6)
                set the value of #inv_norm_prob_gt to gt.toFixed(6)

                set half_p to (1.0 - p) / 2.0

                set btwn_gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, half_p)) as Float
                set btwn_lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - half_p)) as Float

                set the value of #inv_norm_prob_btwn1 to btwn_gt.toFixed(6)
                set the value of #inv_norm_prob_btwn2 to btwn_lt.toFixed(6)

                set half_p2 to p / 2.0

                set out_lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, half_p2)) as Float
                set out_gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - half_p2)) as Float

                set the value of #inv_norm_prob_out1 to out_lt.toFixed(6)
                set the value of #inv_norm_prob_out2 to out_gt.toFixed(6)
            end
        end
    end

    behavior SampleInvNormCalcTextUpdate
        on keyup or input
            set mean to the value of #sample_inv_norm_prob_calc_mean
            set stdev to the value of #sample_inv_norm_prob_calc_stdev
            set n to the value of #sample_inv_norm_prob_calc_n
            set p to the value of #sample_inv_norm_prob_calc_p

            if has_val(mean) and has_val(stdev) and has_val(p)
                set stdev to stdev / Math.sqrt(n)
                set n to Math.max(Math.floor(n), 1)
                set p to Math.min(Math.max(p, 0.0), 1.0)

                set lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, p)) as Float
                set gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - p)) as Float

                set the value of #sample_inv_norm_prob_lt to lt.toFixed(6)
                set the value of #sample_inv_norm_prob_gt to gt.toFixed(6)

                set half_p to (1.0 - p) / 2.0

                set btwn_gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, half_p)) as Float
                set btwn_lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - half_p)) as Float

                set the value of #sample_inv_norm_prob_btwn1 to btwn_gt.toFixed(6)
                set the value of #sample_inv_norm_prob_btwn2 to btwn_lt.toFixed(6)

                set half_p2 to p / 2.0

                set out_lt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, half_p2)) as Float
                set out_gt to
                    x_from_z(mean, stdev, inv_norm_cdf_fn(mean, stdev, 1.0 - half_p2)) as Float

                set the value of #sample_inv_norm_prob_out1 to out_lt.toFixed(6)
                set the value of #sample_inv_norm_prob_out2 to out_gt.toFixed(6)
            end
        end
    end

    behavior TypeTwoMeanTextUpdate
        on keyup or input or changed
            set pop_mean to the value of #type_two_error_mean
            set stdev to the value of #type_two_error_stdev
            set n to the value of #type_two_error_n
            set alpha to the value of #type_two_error_alpha
            set sample_mean to the value of #type_two_error_observed
            
            -- This works better than checking if each is checked, for some reason
            set tail_type to 1
            if #type_two_error_ne.checked
                set tail_type to 2
            end

            if has_val(pop_mean) 
                    and has_val(stdev) 
                    and has_val(n) 
                    and has_val(alpha) 
                    and has_val(sample_mean)
                    and tail_type > 0
                set stdev to stdev / Math.sqrt(n)
                set n to Math.max(Math.floor(n), 1)
                set alpha to Math.min(Math.max(alpha, 0.0), 1.0)

                if tail_type > 0
                    -- Find critical Z on null hypothesis mean
                    set null_crit_prob to alpha
                    set null_crit_z to inv_norm_cdf_fn(0, 1, null_crit_prob)
                    if sample_mean > pop_mean
                        set null_crit_z to -null_crit_z
                    end
                    set the value of #type_two_error_crit_z_null to null_crit_z.toFixed(6)

                    -- Find the numerical value of this Z-score
                    set null_crit_val to x_from_z(pop_mean, stdev, null_crit_z)
                    set the value of #type_two_error_crit_val_null to null_crit_val.toFixed(6)

                    -- Find the Z-score on the alternative hypothesis distribution
                    set alt_crit_z to z_score_fn(sample_mean, stdev, null_crit_val)
                    set the value of #type_two_error_crit_z_alt to alt_crit_z.toFixed(6)

                    -- Power & probability
                    set power to 0.0
                    set beta to 0.0
                    set reject_text to ""
                    if sample_mean <= pop_mean
                        -- If the sample mean is greater than the population 
                        -- mean (and we're performing a one-tail test), we want
                        -- the probability area for values below the given critical
                        -- value to represent the power.
                        set power to norm_prob_cdf_fn(0, 1, alt_crit_z)
                        set beta to 1.0 - power

                        if sample_mean < null_crit_val
                            set reject_text to "Yes"
                        else
                            set reject_text to "No"
                        end
                    else
                        -- Flip to the right side of this distribution if we're 
                        -- doing a one-tailed test, we want the right tail from the 
                        -- critical point between the population and sampled means.
                        --  set power to norm_prob_cdf_fn(sample_mean, stdev, 1.0 - alt_crit_z)
                        set beta to norm_prob_cdf_fn(0, 1, alt_crit_z)
                        set power to 1.0 - beta

                        if sample_mean > null_crit_val
                            set reject_text to "Yes"
                        else
                            set reject_text to "No"
                        end
                    end
                    set the value of #type_two_error_power to power.toFixed(6)
                    set the value of #type_two_error_crit_alt_tail to beta.toFixed(6)
                    set the innerHTML of #type_two_reject_null to reject_text
                else
                    -- If it doesn't exist, clear the probability?
                    -- Also I should clear outputs whenever inputs are invalid 
                    -- so users know which are the issues.
                end
            end
        end
    end

    behavior TScoreTextUpdate
        on keyup or input
            set mean to the value of #t_score_calc_mean
            set stdev to the value of #t_score_calc_stdev
            set n to the value of #t_score_calc_n
            set x to the value of #t_score_calc_x

            if has_val(mean) and has_val(stdev) and has_val(n) and has_val(x)
                set n to Math.max(Math.floor(n), 1)

                set t_score to t_score_fn(mean, stdev, n, x)
                set #t_score_output's value to t_score.toFixed(6)
            end
        end
    end

    behavior TInvNormCalcTextUpdate
        on keyup or input
            set n to the value of #t_inv_norm_prob_calc_n
            set p to the value of #t_inv_norm_prob_calc_p

            if has_val(n) and has_val(p)
                set n to Math.max(Math.floor(n), 2)
                set p to Math.min(Math.max(p, 0.0), 1.0)

                set lt to
                    inv_t_cdf_fn(n, p) as Float
                set gt to
                    inv_t_cdf_fn(n, 1.0 - p) as Float

                set the value of #t_inv_norm_prob_lt to lt.toFixed(6)
                set the value of #t_inv_norm_prob_gt to gt.toFixed(6)

                set half_p to (1.0 - p) / 2.0

                set btwn_gt to inv_t_cdf_fn(n, half_p) as Float
                set btwn_lt to inv_t_cdf_fn(n, 1.0 - half_p) as Float

                set the value of #t_inv_norm_prob_btwn1 to btwn_gt.toFixed(6)
                set the value of #t_inv_norm_prob_btwn2 to btwn_lt.toFixed(6)

                set half_p2 to p / 2.0

                set out_lt to inv_t_cdf_fn(n, half_p2) as Float
                set out_gt to inv_t_cdf_fn(n, 1.0 - half_p2) as Float

                set the value of #t_inv_norm_prob_out1 to out_lt.toFixed(6)
                set the value of #t_inv_norm_prob_out2 to out_gt.toFixed(6)
            end
        end
    end
</script>